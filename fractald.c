/* Sample assembly language program for the x86 CPU by
   Mark Craig (mandelbrot and julia fractals) (Linux)
   https://www.youtube.com/MrMcSoftware */

/* I chose to use assembly and C mix because I didn't want to code the Linux
   GUI stuff in assembly.  My original assembly language fractal program was
   written for a CPU I designed.  That version was all assembly and was the
   basis for this x86 version. */

#include <stdio.h>
#include <stdlib.h>
#include <X11/Xlib.h>
#include <X11/X.h>
#include <X11/Xutil.h>
#include <X11/Xos.h>		/* Not needed if include string.h */
//#include <X11/Xatom.h>	/* Not needed */
#ifdef HAVE_SDL2
#include <SDL2/SDL.h>
#endif
#ifndef NO_XPM
#include <X11/xpm.h>
#include "myicon.xpm"
#endif

#define MANDELBROT 0
#define JULIA 1

typedef struct Points		/* mimic Windows POINTS type */
	{
	int x, y;
	} POINTS;

	/* Linux GUI variables */

GC gc;						/* XWindow Graphic Context */
Display *dpy;				/* Connection to the X server */
Window win;					/* Window handle */
XImage *ximage = NULL;		/* XWindow bitmap image structure */
Atom wmDeleteMessage;		/* Message sent when user clicks "x" close button */
int width, height;			/* Window client area dimensions */
POINTS pt0, pts, pte;       /* zoom: old point, start point, end point */

	/* Variables used in assembly part */

	/* some of these variables are vestiges of my original assembly language
	   fractal program for my CPU design which this x86 version is based on.
	   That CPU design was simpler than x86, so these vars. were necessary. */

unsigned char im[512*512*4];	/* Image buffer */
double aedge1 = -2.0, bedge1 = -1.25, xdelta1 = 3.0, ydelta1 = 2.5;
double aedge2 = -1.061955193, bedge2 = -.264645193;
double xdelta2 = .000230386, ydelta2 = .000230386;
double aedge3 = -1.2125216, bedge3 = -.3355226;
double xdelta3 = .1620652, ydelta3 = .1620652;
double aedge4 = -1.5, bedge4 = -1.4, xdelta4 = 3.0, ydelta4 = 2.8;
double aedge5 = 0.33285461273437479100, bedge5 = 0.57068114093749985900;
double xdelta5 = 0.1395625000000000000e-04, ydelta5 = 0.1395625000000000000e-04;
double a1 = -.8, b1 = .156, a2 = -.742, b2 = .1, a3 = -.4, b3 = .6;
double a4 = .285, b4 = .01, a5 = 0.0, b5 = -.8, a6 = -.835, b6 = -.2321;
double a7 = -.1, b7 = .651, a8 = .3, b8 = 0.0, a = -.8, b = .156;
double xres1 = 512.0, yres1 = 512.0, xres = 512.0, yres = 512.0;
double xres2 = 256.0, yres2 = 256.0;
double one = 1.0, two = 2.0, converge = 4.0, popped;
double m, n, xgap, ygap, ac, bc, az, bz, sizev, temp, tempb;
double aedge, bedge, xdelta, ydelta;
int numpixels = 512*512*4, numpixels1 = 512*512*4, numpixels2 = 512*256*4;
int off = 0, ncols = 255, count, limit = 1023;
int pixel, cyinc = 2, cydir = 1;
int resadd = 0, resadd1 = 0, resadd2 = 256*4;
int imaged[512*512];		/* "count" buffer used for color cycling */

	/* Rainbow colortable generated by HSV to RGB conversion (hue: 0 to 360) */

unsigned char Colors[256*3] = {
	0,0,0,
	255,6,0,
	255,12,0,
	255,18,0,
	255,24,0,
	255,30,0,
	255,36,0,
	255,42,0,
	255,48,0,
	255,54,0,
	255,60,0,
	255,66,0,
	255,72,0,
	255,78,0,
	255,84,0,
	255,90,0,
	255,96,0,
	255,102,0,
	255,108,0,
	255,114,0,
	255,120,0,
	255,126,0,
	255,132,0,
	255,138,0,
	255,144,0,
	255,150,0,
	255,156,0,
	255,162,0,
	255,168,0,
	255,174,0,
	255,180,0,
	255,186,0,
	255,192,0,
	255,198,0,
	255,204,0,
	255,210,0,
	255,216,0,
	255,222,0,
	255,228,0,
	255,234,0,
	255,240,0,
	255,246,0,
	255,252,0,
	252,255,0,
	246,255,0,
	239,255,0,
	233,255,0,
	227,255,0,
	221,255,0,
	215,255,0,
	209,255,0,
	203,255,0,
	197,255,0,
	191,255,0,
	185,255,0,
	179,255,0,
	173,255,0,
	167,255,0,
	161,255,0,
	155,255,0,
	149,255,0,
	143,255,0,
	137,255,0,
	131,255,0,
	125,255,0,
	119,255,0,
	113,255,0,
	107,255,0,
	101,255,0,
	95,255,0,
	89,255,0,
	83,255,0,
	77,255,0,
	71,255,0,
	65,255,0,
	59,255,0,
	53,255,0,
	47,255,0,
	41,255,0,
	35,255,0,
	29,255,0,
	23,255,0,
	17,255,0,
	11,255,0,
	5,255,0,
	0,255,0,
	0,255,6,
	0,255,12,
	0,255,18,
	0,255,24,
	0,255,30,
	0,255,36,
	0,255,42,
	0,255,48,
	0,255,54,
	0,255,60,
	0,255,66,
	0,255,72,
	0,255,78,
	0,255,84,
	0,255,90,
	0,255,96,
	0,255,102,
	0,255,108,
	0,255,114,
	0,255,120,
	0,255,126,
	0,255,132,
	0,255,138,
	0,255,144,
	0,255,150,
	0,255,156,
	0,255,162,
	0,255,168,
	0,255,174,
	0,255,180,
	0,255,186,
	0,255,192,
	0,255,198,
	0,255,204,
	0,255,210,
	0,255,216,
	0,255,222,
	0,255,228,
	0,255,234,
	0,255,240,
	0,255,246,
	0,255,252,
	0,251,255,
	0,245,255,
	0,239,255,
	0,233,255,
	0,227,255,
	0,221,255,
	0,215,255,
	0,209,255,
	0,203,255,
	0,197,255,
	0,191,255,
	0,185,255,
	0,179,255,
	0,173,255,
	0,167,255,
	0,161,255,
	0,155,255,
	0,149,255,
	0,143,255,
	0,137,255,
	0,131,255,
	0,125,255,
	0,119,255,
	0,113,255,
	0,107,255,
	0,101,255,
	0,95,255,
	0,89,255,
	0,83,255,
	0,77,255,
	0,71,255,
	0,65,255,
	0,59,255,
	0,53,255,
	0,47,255,
	0,41,255,
	0,35,255,
	0,29,255,
	0,23,255,
	0,17,255,
	0,11,255,
	0,5,255,
	0,0,255,
	6,0,255,
	12,0,255,
	18,0,255,
	24,0,255,
	30,0,255,
	36,0,255,
	42,0,255,
	48,0,255,
	54,0,255,
	60,0,255,
	66,0,255,
	72,0,255,
	78,0,255,
	84,0,255,
	90,0,255,
	96,0,255,
	102,0,255,
	108,0,255,
	114,0,255,
	120,0,255,
	126,0,255,
	132,0,255,
	138,0,255,
	144,0,255,
	150,0,255,
	156,0,255,
	162,0,255,
	168,0,255,
	174,0,255,
	180,0,255,
	186,0,255,
	192,0,255,
	198,0,255,
	204,0,255,
	210,0,255,
	216,0,255,
	222,0,255,
	228,0,255,
	234,0,255,
	240,0,255,
	246,0,255,
	252,0,255,
	255,0,251,
	255,0,245,
	255,0,239,
	255,0,233,
	255,0,227,
	255,0,221,
	255,0,215,
	255,0,209,
	255,0,203,
	255,0,197,
	255,0,191,
	255,0,185,
	255,0,179,
	255,0,173,
	255,0,167,
	255,0,161,
	255,0,155,
	255,0,149,
	255,0,143,
	255,0,137,
	255,0,131,
	255,0,125,
	255,0,119,
	255,0,113,
	255,0,107,
	255,0,101,
	255,0,95,
	255,0,89,
	255,0,83,
	255,0,77,
	255,0,71,
	255,0,65,
	255,0,59,
	255,0,53,
	255,0,47,
	255,0,41,
	255,0,35,
	255,0,29,
	255,0,23,
	255,0,17,
	255,0,11,
	255,0,5,
	255,0,5};

	/* Variables used in C part */

double aedgeUndo, bedgeUndo, xdeltaUndo, ydeltaUndo;	/* zoom undo vars */
int zoomgetpoint = 0, zoomtype, keepitsquare = 1;		/* zoom vars */
int speed = 0, dspeed = 10, pauseit = 0, cycle = 0;		/* color cycle vars */
int fractaltype;

int graphinit(), graphterm(), ProcessEvents();

	/* Routines from assembly */

extern void _Mandelbrot(), _Julia(), _Cycle(), Choice0(), Choice1(), Choice2();
extern void Choice3(), Choice4(), Choice5(), Choice6(), Choice7(), Choice8();
extern void Choice9(), Choicea(), Choiceb(), Choicem();

	/* A few routines that call the assembly routines.  BTW, I purposely chose
	   to use basic x86 assembly - no SSE*, no AVX-512, etc. */

void Mandelbrot()
{
_Mandelbrot();
XPutImage(dpy, win, gc, ximage, 0, 0, 0, 0, ximage->width, ximage->height);
}
			
void Julia()
{
_Julia();
XPutImage(dpy, win, gc, ximage, 0, 0, 0, 0, ximage->width, ximage->height);
}
			
	/* Colortable cycling */

void Cycle()
{
_Cycle();
XPutImage(dpy, win, gc, ximage, 0, 0, 0, 0, ximage->width, ximage->height);
}

	/* Linux / XWindows GUI stuff */

void ClearScreen()
{
memset(im, 0, 512*512*4);
memset(imaged, 0, 512*512*4);
//XPutImage(dpy, win, gc, ximage, 0, 0, 0, 0, ximage->width, ximage->height);
XClearWindow(dpy, win);
}

void SaveImage()
{
FILE *fp;
char str[256], str2[256];
unsigned char *p = im;

while (1)
	{
	printf("Enter filename: ");
	scanf("%s", str);
	if ((fp = fopen(str, "r")) != NULL)
		{
		printf("%s already exists.  Overwrite (y/n)?: ", str);
		fclose(fp);
		scanf("%s", str2);
		if (str2[0] == 'y') { break; }
		}
	else { break; }
	}
if ((fp = fopen(str, "wb")) == NULL)
	{
	printf("Can't save to desired file\n");
	return;
	}
fprintf(fp, "P6\n512 512\n255\n");
for (n=0; n<512; n++)
	for (m=0; m<512; m++)
		{
		fputc(*(p+2), fp);
		fputc(*(p+1), fp);
		fputc(*(p), fp);
		p+=4; // 32-bit image buffer instead of 24
		}
fclose(fp);
sprintf(str2, "ls -al %s", str); system(str2);
}

void parameters()
{
char str[256];

printf("a edge:  %.10lf\t\tb edge:  %.10lf\n", aedge, bedge);
printf("x delta: %.10lf\t\ty delta: %.10lf\n", xdelta, ydelta);
printf("Julia a: %.10lf\t\tJulia b: %.10lf\n", a, b);
printf("Limit: %d\n", limit);
if (fractaltype == MANDELBROT) { printf("Mandelbrot\n"); }
else { printf("Julia\n"); }
printf("Change (y/n)?: ");
scanf("%s", str);
if (str[0] != 'y') { return; }
printf("Enter a edge (or n to default to %.10lf): ", aedge);
scanf("%s", str); if (str[0] != 'n') { sscanf(str, "%lf", &aedge); }
printf("Enter b edge (or n to default to %.10lf): ", bedge);
scanf("%s", str); if (str[0] != 'n') { sscanf(str, "%lf", &bedge); }
printf("Enter x delta (or n to default to %.10lf): ", xdelta);
scanf("%s", str); if (str[0] != 'n') { sscanf(str, "%lf", &xdelta); }
printf("Enter y delta (or n to default to %.10lf): ", ydelta);
scanf("%s", str); if (str[0] != 'n') { sscanf(str, "%lf", &ydelta); }
printf("Enter Julia a (or n to default to %.10lf): ", a);
scanf("%s", str); if (str[0] != 'n') { sscanf(str, "%lf", &a); }
printf("Enter Julia b (or n to default to %.10lf): ", b);
scanf("%s", str); if (str[0] != 'n') { sscanf(str, "%lf", &b); }
printf("Enter Limit (or n to default to %d): ", limit);
scanf("%s", str); if (str[0] != 'n') { sscanf(str, "%d", &limit); }
printf("Currently %s, Change (y/n): ", fractaltype ? "Julia" : "Mandelbrot");
scanf("%s", str);
if (str[0] == 'y') { fractaltype = !fractaltype; }
if (fractaltype == MANDELBROT) { Mandelbrot(); } else { Julia(); }
}

int main(int argc, char *argv[])
{
int i, l;
char str[8];
XEvent event;
XKeyEvent kev;

graphinit();
if (argc == 1) { Choice1(); } // start with first location
// Wait for window to popup
do { XNextEvent(dpy, &event); } while (event.type != Expose);
// fake keypresses so user can initialize the way they want
if (argc > 1)
	{
	kev.display = dpy;
	kev.window = win;
	str[1] = '\0';
	l = strlen(argv[1]); // putting strlen in "for" didn't work
	for (i=0; i<l; i++)
		{
		kev.type = KeyPress;
		str[0] = argv[1][i];
		// handle cases that don't work with Keysym/Keycode
		switch (str[0])
			{
			case '-': kev.keycode = 20; break;
			case '.': kev.keycode = 60; break;
			case ',': kev.keycode = 59; break;
			default: kev.keycode = XKeysymToKeycode(dpy, XStringToKeysym(str));
			}
		XSendEvent(dpy, win, True, KeyPressMask, (XEvent *)&kev);
		kev.type = KeyRelease;
		XSendEvent(dpy, win, True, KeyPressMask, (XEvent *)&kev);
		}
	}
else { XPutImage(dpy, win, gc, ximage, 0, 0, 0, 0, ximage->width, ximage->height); }
XFlush(dpy);
while (1)
	{
	/* trying to be nice on CPU - only continuously run while loop when
	   color cycling, otherwise, use XPeekEvent which waits for event */
	if ((cycle) && (!pauseit))
		{
		Cycle();
		if (speed > 1) { usleep(speed*500); }
		if (XPending(dpy)) { ProcessEvents(str); } 
		}
	else { if (XPeekEvent(dpy, &event)) { ProcessEvents(str); } }
	if (str[0] == 'q') { break; }
	}
}

int graphinit()
{
XGCValues gcvalues;
XSizeHints hints;
XWMHints wm_hints;
Visual *visual;
XVisualInfo vis;
XSetWindowAttributes wa;
Pixmap icon;
int depth = 24;
int border_width = 0;
int screen_num;
unsigned int class;
unsigned long valuemask;
char *display_name = NULL;

/* I copied this routine from some other code I wrote.  I took out the
   unneeded (in this project) code I saw, but there still might be some more */
 
if ((dpy = XOpenDisplay(display_name)) == NULL)
	{
	printf("Cannot connect to X server %s\n", XDisplayName(display_name));
	exit(-1);
	}
screen_num = DefaultScreen(dpy);
depth = DefaultDepth(dpy, screen_num);
width = 512;
height = 513;  // some window decoration themes/window managers need extra
if (depth > 8)
	{
	//visual = DefaultVisual(dpy, screen_num);
	vis.depth = depth;
	XMatchVisualInfo(dpy, screen_num, vis.depth, TrueColor, &vis);
	visual = vis.visual;
	valuemask = CWColormap | CWBackPixel | CWBorderPixel;
	wa.background_pixel = BlackPixel(dpy, screen_num);
	wa.border_pixel = BlackPixel(dpy, screen_num);
	class = InputOutput;
	wa.colormap = XCreateColormap(dpy, RootWindow(dpy, screen_num), visual, AllocNone);
	win = XCreateWindow(dpy, RootWindow(dpy, screen_num),
		0, 0, width, height, border_width, vis.depth, class,
		visual, valuemask, &wa);
	wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
	XSetWMProtocols(dpy, win, &wmDeleteMessage, 1);
	}
hints.flags = PPosition | PSize;
hints.x = hints.y = 0;
hints.width = width;
hints.height = height;
XSetNormalHints(dpy, win, &hints);
XStoreName(dpy, win, "Mark's x86 Asm. Fractals (Linux)");
XSetInputFocus(dpy, PointerRoot, RevertToNone, CurrentTime);
wm_hints.initial_state = NormalState;
wm_hints.input = True;
#ifndef NO_XPM
// IconPixmapHint method might only work in Gnome
XpmCreatePixmapFromData(dpy, win, myicon, &icon, NULL, NULL);
wm_hints.icon_pixmap = icon;
wm_hints.flags = StateHint | IconPixmapHint | InputHint;
#else
wm_hints.flags = StateHint | InputHint;
#endif
XSetWMHints(dpy, win, &wm_hints);
XSelectInput(dpy, win, ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask | StructureNotifyMask | PointerMotionMask);
XMapWindow(dpy, win);
gc = XCreateGC(dpy, win, 0L, &gcvalues);
ximage = XCreateImage(dpy, visual, depth, ZPixmap, 0, 0, 512, 512, 8, 0);
if (ximage == NULL) { printf("Can't create image buffer\n"); return(1); }
//ximage->data = calloc(height, ximage->bytes_per_line);
ximage->data = im;
XSetForeground(dpy, gc, WhitePixel(dpy, 0));
}

int graphterm()
{
static int term = 0;

if (term) { return(1); }
XFlush(dpy);
if (ximage != NULL) { ximage->data = NULL; XDestroyImage(ximage); ximage = NULL; }
XFreeGC(dpy, gc);
XDestroyWindow(dpy, win);
XCloseDisplay(dpy);
term = 1;
}

int ProcessEvents(char *key)
{
XEvent event;
char str[512], string[128];
POINTS pt;
double ae, be, ae2, be2;
int dx, dy;

key[0] = string[0] = '\0';
if (XCheckTypedWindowEvent(dpy, win, Expose, &event))
	{
	XPutImage(dpy, win, gc, ximage, 0, 0, 0, 0, ximage->width, ximage->height);
	}
if (XCheckTypedWindowEvent(dpy, win, ClientMessage, &event))
	{
	if (event.xclient.data.l[0] == wmDeleteMessage)
		{
		key[0] = 'q'; graphterm(); return(1);
		}
	}
if (XCheckTypedWindowEvent(dpy, win, KeyPress, &event))
	{
	XLookupString(&event.xkey, string, 128, NULL, NULL);
	switch (event.xkey.keycode)
		{
		case 113: speed-=dspeed; if (speed < 0) { speed = 0; } break; // left
		case 114: speed+=dspeed; break; // right
		}
	key[0] = string[0];
	switch (string[0])
		{
		case '0': Choice0(); break;
		case '1': Choice1(); break;
		case '2': Choice2(); break;
		case '3': Choice3(); break;
		case '4': Choice4(); break;
		case '5': Choice5(); break;
		case '6': Choice6(); break;
		case '7': Choice7(); break;
		case '8': Choice8(); break;
		case '9': Choice9(); break;
		case 'a': Choicea(); break;
		case 'b': Choiceb(); ClearScreen(); break;
		case '-': Choicem(); break;
		case 'q': graphterm(); return(1); break;
		case 'c': cycle = !cycle; break;
		case 'd': if (cydir == 1) { cydir = -1; } else { cydir = 1; } break;
		case ' ': pauseit = !pauseit; break;
		case ',': cyinc-=2; break;
		case '.': cyinc+=2; break;
		case 'z': zoomgetpoint = 1; zoomtype = 0; pt0.x = -1;
			XSetFunction(dpy, gc, GXxor); break;
		case 'x': zoomgetpoint = 1; zoomtype = 1; pt0.x = -1;
			XSetFunction(dpy, gc, GXxor); break;
		case 'u': aedge = aedgeUndo; bedge = bedgeUndo;
			xdelta = xdeltaUndo; ydelta = ydeltaUndo;
			if (fractaltype == MANDELBROT) { Mandelbrot(); } else { Julia(); }
			break;
		case 'k': keepitsquare = !keepitsquare; break;
		case 'p': parameters(); break;
		case 'r': if (fractaltype == MANDELBROT) { Mandelbrot(); } else { Julia(); } break;
		case 's': SaveImage(); break;
		case 'h':
#ifdef HAVE_SDL2
			SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_INFORMATION,
				"Keyboard Controls",
#else
			printf(
#endif
"\
1 - Mandelbrot location 1\n\
2 - Mandelbrot location 2\n\
3 - Mandelbrot location 3\n\
4 - Julia location 1\n\
5 - Julia location 2\n\
6 - Julia location 3\n\
7 - Julia location 4\n\
8 - Julia location 5\n\
9 - Julia location 6\n\
0 - Julia location 7\n\
a - Julia location 8\n\
b - Toggle size\n\
- - Mandelbrot location 4\n\
r - Recalculate/redraw (use after 'b', for example)\n\
z - Zoom by opposing corners\n\
x - Zoom by center to corner\n\
u - Undo zoom\n\
k - Toggle zoom square/free\n\
c - Toggle color cycle\n\
d - Change cycle direction\n\
, - Decrease cycle delta\n\
. - Increase cycle delta\n\
s - Save image\n\
{left} - Increase cycle speed\n\
{right} - Decrease cycle speed\n\
{space} - Pause cycle\n\
h - Help\n\
q - Quit\n\
"
#ifdef HAVE_SDL2
,NULL); // printf would be ok with this, but wanted to avoid compiler warning
#else
);
#endif
			break;
		}
	}
if (XCheckTypedWindowEvent(dpy, win, ConfigureNotify, &event))
	{
	if ((event.xconfigure.width != width)||(event.xconfigure.height != height))
		{
		width = event.xconfigure.width;
		height = event.xconfigure.height;
		XPutImage(dpy, win, gc, ximage, 0, 0, 0, 0, ximage->width, ximage->height);
		}
	}
if (XCheckTypedWindowEvent(dpy, win, ButtonPress, &event))
	{
	XButtonEvent *e = (XButtonEvent *)&event;
	if (e->button == 1)
		{
		if (zoomgetpoint == 1)
			{
			if (pt0.x >= 0)
				{
				XDrawLine(dpy, win, gc, 0, pt0.y, 512, pt0.y);
				XDrawLine(dpy, win, gc, pt0.x, 0, pt0.x, 512);
				}
			pts.x = e->x; pts.y = e->y; zoomgetpoint = 2; pte.x = -1;
			}
		}
	}
if (XCheckTypedWindowEvent(dpy, win, ButtonRelease, &event))
	{
	XButtonEvent *e = (XButtonEvent *)&event;
	if (e->button == 1)
		{
		if (zoomgetpoint == 2)
			{
			XSetFunction(dpy, gc, GXcopy);
			aedgeUndo = aedge; bedgeUndo = bedge;
			xdeltaUndo = xdelta; ydeltaUndo = ydelta;
			if (zoomtype)
				{
				dx = abs(pte.x-pts.x); dy = abs(pte.y-pts.y);
				ae = aedge+xdelta*(double)(pts.x-dx)/(double)(512);
				be = bedge+ydelta*(double)(pts.y-dy)/(double)(512);
				ae2 = aedge+xdelta*(double)(pts.x+dx)/(double)(512);
				be2 = bedge+ydelta*(double)(pts.y+dy)/(double)(512);
				}
			else
				{
				ae = aedge+xdelta*(double)(pts.x)/(double)(512);
				be = bedge+ydelta*(double)(pts.y)/(double)(512);
				ae2 = aedge+xdelta*(double)(pte.x)/(double)(512);
				be2 = bedge+ydelta*(double)(pte.y)/(double)(512);
				}
			aedge = ae; bedge = be;
			xdelta = ae2-ae; ydelta = be2-be;
			zoomgetpoint = 0;
			if (fractaltype == MANDELBROT) { Mandelbrot(); } else { Julia(); }
			XStoreName(dpy, win, "Mark's x86 Asm. Fractals (Linux)");
			}
		}
	}
if (XCheckTypedWindowEvent(dpy, win, MotionNotify, &event))
	{
	XMotionEvent *e = (XMotionEvent *)&event;
	if (zoomgetpoint == 1)
		{
		pt.x = e->x; pt.y = e->y;
		if (pt0.x >= 0)
			{
			XDrawLine(dpy, win, gc, 0, pt0.y, 512, pt0.y);
			XDrawLine(dpy, win, gc, pt0.x, 0, pt0.x, 512);
			}
		XDrawLine(dpy, win, gc, 0, pt.y, 512, pt.y);
		XDrawLine(dpy, win, gc, pt.x, 0, pt.x, 512);
		ae = aedge+xdelta*(double)(pt.x)/(double)(512);
		be = bedge+ydelta*(double)(pt.y)/(double)(512);
		sprintf(str, "%.10lf %.10lf", ae, be);
		XStoreName(dpy, win, str);
		pt0 = pt;
		}
	else if (zoomgetpoint == 2)
		{
		if (zoomtype)
			{
			if (pte.x >= 0)
				{
				dx = abs(pte.x-pts.x); dy = abs(pte.y-pts.y);
				XDrawLine(dpy, win, gc, pts.x-dx, pts.y-dy, pts.x+dy, pts.y-dy);
				XDrawLine(dpy, win, gc, pts.x+dx, pts.y-dy+1, pts.x+dx, pts.y+dy-1);
				XDrawLine(dpy, win, gc, pts.x-dx, pts.y-dy+1, pts.x-dx, pts.y+dy-1);
				XDrawLine(dpy, win, gc, pts.x-dx, pts.y+dy, pts.x+dx, pts.y+dy);
				}
			pte.x = e->x; pte.y = e->y;
			if (keepitsquare) { pte.y = pts.y+(pte.x-pts.x); }
			dx = abs(pte.x-pts.x); dy = abs(pte.y-pts.y);
			XDrawLine(dpy, win, gc, pts.x-dx, pts.y-dy, pts.x+dy, pts.y-dy);
			XDrawLine(dpy, win, gc, pts.x+dx, pts.y-dy+1, pts.x+dx, pts.y+dy-1);
			XDrawLine(dpy, win, gc, pts.x-dx, pts.y-dy+1, pts.x-dx, pts.y+dy-1);
			XDrawLine(dpy, win, gc, pts.x-dx, pts.y+dy, pts.x+dx, pts.y+dy);
			ae = aedge+xdelta*(double)(pts.x-dx)/(double)(512);
			be = bedge+ydelta*(double)(pts.y-dy)/(double)(512);
			ae2 = aedge+xdelta*(double)(pts.x+dx)/(double)(512);
			be2 = bedge+ydelta*(double)(pts.y+dy)/(double)(512);
			}
		else
			{
			if (pte.x >= 0)
				{
				XDrawLine(dpy, win, gc, pts.x, pts.y, pte.x, pts.y);
				XDrawLine(dpy, win, gc, pts.x, pte.y-1, pts.x, pts.y+1);
				XDrawLine(dpy, win, gc, pte.x, pts.y+1, pte.x, pte.y-1);
				XDrawLine(dpy, win, gc, pte.x, pte.y, pts.x, pte.y);
				}
			pte.x = e->x; pte.y = e->y;
			if (keepitsquare) { pte.y = pts.y+(pte.x-pts.x); }
			XDrawLine(dpy, win, gc, pts.x, pts.y, pte.x, pts.y);
			XDrawLine(dpy, win, gc, pts.x, pte.y-1, pts.x, pts.y+1);
			XDrawLine(dpy, win, gc, pte.x, pts.y+1, pte.x, pte.y-1);
			XDrawLine(dpy, win, gc, pte.x, pte.y, pts.x, pte.y);
			ae = aedge+xdelta*(double)(pts.x)/(double)(512);
			be = bedge+ydelta*(double)(pts.y)/(double)(512);
			ae2 = aedge+xdelta*(double)(pte.x)/(double)(512);
			be2 = bedge+ydelta*(double)(pte.y)/(double)(512);
			}
		sprintf(str, "%.10lf %.10lf to %.10lf %.10lf (%.10lf %.10lf)",
			ae, be, ae2, be2, ae2-ae, be2-be);
		XStoreName(dpy, win, str);
		}
	}
}
